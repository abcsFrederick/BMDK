---
title: "README"
output: md_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(BMDK)
library(magrittr)
library(OutlierDetection)
```

# BMDK - Biomarker Discovery Kit

```{r main code}

dat <- read_bmdk(system.file('extdata', 'BMDK_train.txt', package = 'BMDK')) %>%
    detectOutliers_bmdk() #%>%
    # filter_bmdk() %>%
    # pickFeatures_bmdk() %>%
    # validate_bmdk()

# scale/normalize data
# scale each feature in (0,1]

dat$feat <- apply(dat$feat, 2, function(.x){.x / max(.x, na.rm = TRUE)})


# Keep them in the test set

# Impute missing values if desired

# Tests
wresults <- numeric(ncol(dat$feat))
tresults <- numeric(ncol(dat$feat))

for(i in 1:ncol(dat$feat))
{
    # Wilcoxon Rank Sum test
    wresults[i] <- wilcox.test(dat$feat[dat$case == 1,i], dat$feat[dat$case == 0,i], exact = F)[[3]]
  
    # Two Sample t-test
    tresults[i] <- t.test(dat$feat[dat$case == 1,i], dat$feat[dat$case == 0,i])[[3]]
}

# Identify a unique list of the top features from both tests
topfeatures <- unique(c(colnames(dat$feat)[order(wresults)[1:10]],
                        colnames(dat$feat)[order(tresults)[1:10]]))

# Run the list of top features through a Pearson Correlation
# Store the Pearson Correlation coefficients in corrcalculations
corrcalculations <- cor(dat$feat[ ,topfeatures], method = "pearson")

# Identify any features with a high correlation (0.8 <= r < 1.0)
corrfeatures <- which(corrcalculations >= 0.1 & corrcalculations < 1.0, arr.ind = T)

if (length(corrfeatures) > 0)
{
  # If highly correlated features are identified, retrieve those feature names
  # Each row in corrfeaturepairs contains the names of a pair of correlated features
  corrfeaturepairs <- matrix(c(rownames(corrcalculations[corrfeatures[,1], corrfeatures[,2]]),
                        colnames(corrcalculations[corrfeatures[,1], corrfeatures[,2]])), 
                        nrow = nrow(corrfeatures), ncol = ncol(corrfeatures))


  for (i in nrow(corrfeaturepairs))
  {
      if(corrfeaturepairs[i,1] %in% topfeatures &
         corrfeaturepairs[i,2] %in% topfeatures)
      {
      
            # For each pair of features, identify which has a smaller mean value in the original data
        #### NEED TO USE THE ORIGINAL UNNORMALIZED DATA FOR THIS, FIX ###
            featuremaxes <- c(mean(dat$feat[,corrfeaturepairs[i,1]]),
                              mean(dat$feat[,corrfeaturepairs[i,2]]))
    
            minfeature <- min(featuremaxes)
    
            # Throw out the feature in topfeatures that has the smaller mean value
            topfeatures <- topfeatures[-match(corrfeaturepairs[i, match(minfeature,
                                                                        featuremaxes)],
                                              topfeatures)]
      }
  }
}

```
